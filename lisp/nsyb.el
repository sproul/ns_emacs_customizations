(provide 'nsyb)
(setq nsyb-batch-mode	nil)
(defvar nsyb-cm-locked "")
(make-variable-buffer-local 'nsyb-cm-locked)
(set-default 'nsyb-cm-locked "")

(defun nsyb-trc( msg &rest args)
                                        ;(apply 'n-trace msg args)
  )

(defun nsyb-file-hdr( &optional arg)
  "insert Sybase-style source code file header"
  (interactive "P")
  (goto-char (point-min))
  (cond
   ((or
     (equal (nfn-suffix) "cpp")
     (equal (nfn-suffix) "inl")
     (equal (nfn-suffix) "i")
     (equal (nfn-suffix) "cc")
     )
    (if (not (looking-at "#if ! lint"))
        (nsyb-file-hdr-hc "cpp")
      )
    )
   ((equal (nfn-suffix) "h")
    (if (looking-at "/\\*")
        (nc-make-ifdef-tags-correct)
      (nsyb-file-hdr-hc "h")
      (nsimple-delete-line 3)
      (insert "**  This file contains the interface to the module "
              (file-name-nondirectory (buffer-file-name)))
      (backward-delete-char 1)
      (insert "c.\n")
      )
    )
   ((string-match "^make" (buffer-name))
    (insert "##SYBASE_MAKE:	@@program\n")
    (goto-char (point-min))
    )
   )
  )
(defun nsyb-file-hdr-hc(suffix)
  (insert-file (concat  "$dp/data/" "header." suffix))
  (goto-char (point-min))
  ;;  (n-s "FILE_NAME")
  ;;  (nsimple-delete-line)
  ;;  (insert "**  " (buffer-name) "\n")
  (goto-char (point-min))
  (n-complete-leap)
  )

(defun nsyb-hdr-all()
  (interactive)
  (goto-char (point-min))
  (replace-regexp "[ \t]+\n" "\n")
  (nc-goto-1rst-proc-hdr)
  (while (nsyb-hdr))
  )

(defun nsyb-hdr( &optional arg)
  "produce the skeleton for a Sybase-style proc header
for the proc whose dcl is under point"
  (interactive "P")
  (while
      (and
       (let(
            (name	(nc-goto-proc-hdr))
            (isVoid	(progn
                          (forward-line -1)
                          (or
                           (looking-at "[^\n]*void")
                           (looking-at "[^\n]*CS_VOID")
                           )
                          )
                        )
            )
         (forward-line -1)
         (if (looking-at "^}$")
             (progn
               (end-of-line)
               (insert "\n")
               )
           )
         (if (looking-at "^[ \t]*$") 
             (nsyb-hdr-insert name isVoid)
           (progn
             
             ;;this code is to protect the output from nsyb-hdr-save-old
             (if (looking-at "^//$") 
                 (progn
                   (nsimple-kill-line)
                   (forward-line 0)
                   (let(
                        (data (buffer-substring-no-properties (point)
                                                (progn
                                                  (n-r "^//" t)
                                                  (forward-line 1)
                                                  (point)
                                                  )
                                                )
                              )
                        )
                     (delete-char (length data))
                     (forward-line -1)
                     (nsimple-kill-line)
                     (nsyb-hdr-insert name isVoid)
                     (forward-line 0)
                     (insert data)
                     )
                   )
               )
             )
           )
         name
         )
       arg	; this indicates that the routine should loop through the file
       (progn
         ;; we are looping through the file.  Get ready to come back later
         (insert " ")
         (n-loc-push)
         (n-s "^}")
         ) 
       ) 
    )
  )
(defun nsyb-hdr-save-old()
  (setq go_go nil)
  (while t
    (n-s "^{" t)
    (if (or go_go (n-q "save "))
        (progn
          (setq go_go t)
          (n-r "(")
          (forward-char -2)
          (setq procedure (n-grab-token))
          (forward-line -1)
          (n-r procedure t)
          (delete-region (progn
                           (end-of-line)
                           (point)
                           )
                         (progn
                           (n-r "/\\*" t)
                           (point)
                           )
                         )
          (insert "//")
          (narrow-to-region (point)(progn
                                     (n-s "\\*/" t)
                                     (point)
                                     )
                            )
          (forward-line 0)
          (delete-char 1)
          (insert "/")
          
	  (require 'n-prune-buf)
          (n-prune-buf "^\\*\\*[ \t]*$")
          (widen)
          (n-s "^}" t)
          )
      )
    )
  )
(defun nsyb-hdr-insert( name isVoid)
  (insert-file (concat  "$dp/data/" "sybase/header_proc." (nfn-suffix)))
  (n-s "FUNC_NAME" t)
  (nsimple-delete-line)
  (insert (format "** %s\n" name))
  (forward-line 1)
  (end-of-line)
  (save-excursion
    (n-s "Returns:" t)
    (if isVoid
        (progn
          (forward-line 1)
          (nsimple-delete-line 2)
          (insert "**  	nothing\n")
          )
      (forward-line 2)
      )
    )
  (nsyb-hdr-insert-parameter-comments)
  
  (let(
       (start	(point))
       )
    (n-s "CURRENT_DATE" t)
    (nsimple-delete-line)
    (insert (format "**		%s	nelson	created\n" (current-time-string)))
    (goto-char start)
    )
  )
(defun nsyb-hdr-insert-parameter-comments()
  (save-excursion
    (let(
         (parameterList	(buffer-substring-no-properties (progn
                                            (n-s "(" t)
                                            (point)
                                            )
                                          (progn
                                            (n-s ")" t)
                                            (forward-char -1)
                                            (point)
                                            )
                                          )
                        )
         )
      (n-r "^PARAMETERS")
      (nsimple-kill-line)
      (save-restriction
        (narrow-to-region (point)(point))
        (if (string= parameterList "")
            (insert "**	none\n")
          (insert parameterList)
          (goto-char (point-min))
          (replace-regexp "," "\n")
          
          (goto-char (point-min))
          (replace-regexp "^[ \t]*" "**\t@@")
          
          (goto-char (point-min))
          (while (n-s "@@")
            (backward-delete-char 2)
            (nsyb-hdr-insert-parameter-comments-1)
            )
          (goto-char (point-max))
          (insert "\n")
          )
        )
      )
    )
  )

(setq nsyb-variable-information
      (list
       (list "threadId"	"integer identifying a thread")
       (list "workQueue"	"list of units of work")
       (list "conditionVariable"	"@@condition variable structure")
       (list "testHandle"	"test handle")
       (list "reference"	"@@integer referring to a condition variable")
       (list "fileName"	"name of the file")
       (list "thread"	"thread structure")
       (list "script"	"script structure")
       (list "errorMessage"	"message telling about the error")
       (list "work"	"unit of work")
       (list "threadInstance"	"thread instance structure")
       (list "scriptInstance"	"script instance structure")
       (list "line"	"character string of text from one line of input")
       (list "argc"	"number of arguments")
       (list "argv"	"array of pointers to character string arguments")
       (list "callback"	"pointer to callback function")
       (list "message"	"message string")
       (list "string"	"character string")
       (list "outputLength"	"length of the output data")
       (list "length"	"length of the data")
       )
      )
(defun nsyb-hdr-insert-parameter-comments-1()
  (let(
       (name	(n-grab-token))
       comment	
       )
    (setq comment (cadr (assoc name nsyb-variable-information)))
    (if (not comment)
        (setq comment "@@")
      )
    (end-of-line)
    (insert "\t" comment)
    )
  )
(defun nsyb-status()
  (interactive)
  (n-zap "*ks*")

  (let(
       (data	(prog1
                    (buffer-substring-no-properties
                     (progn
                       (n-file-push n-mail-record)
                       (goto-char (point-max))
                       (n-r "^Subject: Weekly status" t)
                       (forward-line 5)
                       (point)
                       )
                     (progn
                       (forward-line 1)
                       (if (n-s "^To: ")
                           (forward-line -1)
                         (goto-char (point-max))
                         )
                       (forward-line -1)	;; back up above my date stamp
                       (point)
                       )
                     )
                  (n-file-pop)
                  )
                )
       (monthDay (n-month-day))
       )
    (let(
         (month		(car monthDay))
         (day		(cdr monthDay))
         goals
         )
      (mail)
      (goto-char (point-min))
      (end-of-line)
      (insert "clg")
      (forward-line 1)
      (end-of-line)
      (insert "Weekly status")
      (forward-line 2)
      (nsimple-delete-line)
      (insert "Nelson Sproul\n")
      (insert (format "%s %s\n" month day))
      (insert (format "Status report for week ending %s %s\n" month day))
      (insert data)
      (nsyb-status-prep-leaps)
      (goto-char (point-min))
      (n-complete-leap)
      )
    )
  )
(defun nsyb-status-prep-leaps()
  (goto-char (point-min))
  (while (n-s "---")
    (forward-line 1)
    (if (looking-at "Due date:")
        (forward-line 1))
    (insert "@@")
    )
  )
(defun nsyb-cm-cmd()
  (interactive)
  (save-buffer)

  (setq nsyb-source-control-software (cond
                                      ((not (buffer-file-name)) "p4")
                                      ((string-match "^/scratch/" (buffer-file-name)) "ade")
                                      (t "p4")
                                      )
        )
  (n-load (concat "nscm-" nsyb-source-control-software))

  (let(
       (command	(progn
                  (message "a-dd,A-dd to make,b-ackup,f-ile(goto),g-et,l-ock,p-ut,r-m,R-ule data init,t-ouch,u-nlock,v-log")
                  (read-char)
                  )
                )
       )
    (cond
     ((eq command ?a)
      (nsyb-cm "add")
      )
     ((eq command ?A)
      (require 'n-make)
      (n-make-possibly-add-to)
      )
     ((eq command ?b)
      (n-host-shell-cmd-visible (format "cp -f %s %s.new" (buffer-file-name) (buffer-file-name)))
      )
     ((eq command ?B)
      (nsyb-request-client-build-capability-ext)
      )
     ;;((eq command ?B)
     ;;(n-host-shell-cmd-visible (format "cp -f %s %s.old" (buffer-file-name) (buffer-file-name)))
     ;;(n-host-shell-cmd-visible (format "cp -f %s.new %s" (buffer-file-name) (buffer-file-name)))
     ;;)
     ;;((eq command ?c)
     ;;(setq ndiff-opposing-user "ck")
     ;;(nsyb-cofile-cmd)
     ;;)
     ((eq command ?d)
      (save-window-excursion
        (nsyb-codeline-file-cmd (buffer-file-name))
        )
      (ndiff-fn (buffer-file-name)
                (concat
                 (file-name-directory (buffer-file-name))
                 "CODE."
                 (file-name-nondirectory (buffer-file-name))
                 )
                )
      )
     ((eq command ?f)
      (nsyb-codeline-file-cmd (buffer-file-name))
      )
     ((eq command ?g)
      (nsyb-cm "get")
      )
     ((eq command ?G)
      (nsyb-cm "get")
      (n-file-toggle-read-onlyness)
      )
     ((eq command ?l)
      (nsyb-cm-lock)
      )
     ((eq command ?L)
      (nsyb-get (buffer-file-name) "-l")
      )
     ((eq command ?p)
      (nsyb-put (buffer-file-name))
      )
     ((eq command ?r)
      (nsyb-cm "rm")
      )
     ((eq command ?t)
      (n-host-shell-cmd-visible (format "ntouch %s" (buffer-file-name)))
      )
     ((eq command ?u)
      (nsyb-cm-unlock)
      )
     ((eq command ?v)
      (n-host-shell-cmd-visible ( format "pvcs_file_history %s" (buffer-file-name)))
      )
     )
    )
  )

(setq nsyb-put-comment "")

(defun nsyb-put(fn)
  (if (not fn)
      (setq fn (buffer-file-name)))

  (setq nsyb-put-comment (read-string "comment:" nsyb-put-comment))
  (n-host-shell-cmd-visible (format "cd %s; p4 submit" (file-name-directory fn)))
  ;;put -M\"%s\" %s"
  ;;                                nsyb-put-comment
  ;;                              (file-name-nondirectory fn)
  ;;                            )
  ;;                  )
  (sleep-for 2)
  (n-file-refresh-from-disk)
  )

(defun nsyb-shell-cmd()
  (interactive)
  (let(
       (command	(progn
                  (message "g-etalldirs, m-kputall, r-efresh.mail, v-listall")
                  (read-char)
                  )
                )
       )
    (cond
     ((eq command ?g)
      (process-send-string nil "getalldirs\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\n")
      (process-send-string nil "delobsolete\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\n")
      )
     ((eq command ?m)
      (goto-char (point-max))
      (insert "mkputall \"\"")
      (forward-char -1)
      )
     ((eq command ?r)
      (process-send-string nil "refresh.mail\n")
      )
     ((eq command ?v)
      (process-send-string nil "echo ''; vlistall\n")
      )
     )
    )
  )

(defun nsyb-cm(cmd &optional &rest rest)
  (let(
       (sym (intern (concat "nscm-" nsyb-source-control-software "-" cmd)))
       )
    (apply (symbol-function sym) rest)
    )
  )


(defun nsyb-request-client-build-capability-ext()
  (mail)
  (insert "carmen@extensity.com")
  (end-of-line)
  (insert "\ncc: ")
  (n-loc-push)
  (insert "@extensity.com")
  (forward-line 1)
  (end-of-line)
  (insert "request to add " (getenv "extdataset") " to the build request form")
  (goto-char (point-max))
  (insert "hi Carmen,

Could you please arrange to add " (getenv "extdataset") " to the list of supported
customers in the build request form?  This is not an urgent request; if it could
be done in the next week or so, that would be great.

thank you,

Nelson
")
  (n-loc-pop)
  )

(defun nsyb-add-or-edit-all-files-in-buffer()
  (nsyb-cm "add-or-edit" (nfn-get-all-in-buffer))
  )

(defun nsyb-add-to-faq()
  "grab the two lines under (point) and mv 'em into the FAQ"
  (interactive)
  (forward-line 0)
  (insert "\n<h3>")
  (nsimple-upcase-word ?1)

  (end-of-line)
  (just-one-space)
  (delete-char -1)
  (forward-char -1)
  (if (not (looking-at "\\?"))
      (progn
	(forward-char 1)
	(insert "?"))
    (forward-char 1)
    )
  (insert "</h3>\n")

  (kill-region (progn
		 (forward-line -1)
		 (point)
		 )
	       (progn
		 (forward-line 4)
		 (point)
		 )
	       )
  (let(
       h1Section
       (h1SectionAssoc (list
			(cons ?1 "Building the Product")
			(cons ?2 "Configuring the Product")
			(cons ?3 "Credit Card Integration")
			(cons ?4 "Database Management and the Extensity Environment")
			(cons ?5 "Debugging Application Server Problems")
			(cons ?6 "Debugging Client Problems")
			(cons ?7 "Offline Client")
			(cons ?8 "Programming in the Extensity Environment")
			(cons ?9 "Pointers to various info")
			(cons ?0 "Writing Rules")
			)
		       )
       h1Header
       )
    (setq h1Section (nmenu "where? " h1SectionAssoc))
    (if (get-buffer "faq.html")
	(switch-to-buffer "faq.html")
      (n-file-find "//corp-fs1/webint/dept/PSO/CoreGroup/coding/faq.html")
      )
    (goto-char (point-min))
    (n-s h1Section t)
    (forward-line 1)
    (save-restriction
      (narrow-to-region (point) (point))
      (yank)
      (insert "\n")
      (goto-char (point-min))
      (replace-regexp "=http:" "=HtTp:")

      (goto-char (point-min))
      (replace-regexp "\\(http:.*\\(html?[^\\. ]*\\|doc[^\\. ]*\\|/\\)\\)\\([ \t\n]\\)" "<a href='\\1'>@@\\1</a>\\3")

      (goto-char (point-min))
      (replace-regexp "=HtTp:" "=http:")

      (goto-char (point-min))
      (if (n-s "@@")
	  (delete-char -2)
	)
      )
    )
  )
(defun nsyb-harvest-dd-info()
  "assumes preprocessing in current buf where '^!alco_user' precedes defn; column info is always '^:column_name\n:.*?\n:.*?\n:.*?\n:cmt"
  (let(
       table
       colName
       cmt
       ass
       )
    (while (n-s ":\\([^<]+\\)<[^\n]*\n:[^\n]*\n:[^\n]*\n:[^\n]*\n:\\([^<]*\\)")
      (setq colName (n--pat 1)
	    cmt (n--pat 2)
	    table (save-excursion
		    (n-r "^!\\([^<]+\\)" t)
		    (n--pat 1)
		    )
	    ass (cons (cons (concat table "." colName)
			    cmt
			    )
		      ass
		      )
	    )
      )
    (find-file "$dp/emacs/lisp/data/n-data-extensity-dd.el")
    (delete-region (point-min) (point-max))
    (insert "(setq n-data-extensity-dd '" (prin1-to-string ass))
    (insert "\n)\n")
    (downcase-region (point-min) (point-max))
    (nelisp-compile)
    )
  )

(defun nsyb-cm-lock-if-necessary()
  (if (nbuf-read-only-p)
      (progn
	(nsyb-cm "lock")
	(if (nbuf-read-only-p)
	    (error "nsyb-cm-lock-if-necessary: ")
	  )
	)
    )
  )

(setq nsyb-cm-lock-list-fn "~/tmp/locked_list")

(defun nsyb-cm-lock()
  (setq nsyb-cm-locked "L:")
  (save-window-excursion
    (let(
         (fn (buffer-file-name))
         )
      (find-file nsyb-cm-lock-list-fn)
      (insert fn "\n")
      )
    (save-buffer)
    (kill-buffer nil)
    )
  (nsyb-cm "lock")
  )

(defun nsyb-see-if-it-is-locked()
  (let(
       (fn (buffer-file-name))
       )
    (find-file nsyb-cm-lock-list-fn)
    (goto-char (point-min))
    (if (prog1
            (n-s (concat "^" fn "$"))
          (kill-buffer nil)
          )
        (setq nsyb-cm-locked "L:")
      )
    )
  )

(defun nsyb-cm-unlock()
  (setq nsyb-cm-locked "")
  (save-window-excursion
    (let(
         (fn (buffer-file-name))
         )
      (find-file nsyb-cm-lock-list-fn)
      (n-prune-buf (concat "^" fn "$")
                   )
      )
    (save-buffer)
    (kill-buffer nil)
    )
  (nsyb-cm "unlock")
  )

(defun nsyb-do-something-with-a-test()
  (let(
       (test (n-grab-token))
       (cmd (progn
              (message "h-istory, r-un")
              (read-char)
              )
            )
       )
    (cond
     ((eq cmd ?h)
      (n-host-shell-cmd-visible (format "pt_test_history %s" test))
      (goto-char (point-max))
      )
     ((eq cmd ?r)
      (n-host-shell-cmd-visible (format "pt_test_run %s" test))
      (goto-char (point-max))
      )
     )
    )
  )


(defun nscm-call-process(op fn pgm &rest leftover)
  (delete-other-windows)
  (nsimple-split-window-vertically)
  (switch-to-buffer (get-buffer-create "*Messages*"))
  (delete-region (point-min) (point-max))
  (message "calling 4 %s %s" op fn)
  (if (not leftover)
      (setq leftover (list fn))
    (setq leftover (append leftover (list fn)))
    )
  (apply 'call-process
         "bash"
         nil
         "*Messages*"
         t
         pgm
         op
         leftover
         )
  (other-window 1)
  (if (not (string= op "delete"))
      (n-file-refresh-from-disk))
  )
